% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lcm_tree.R
\name{lcm_tree}
\alias{lcm_tree}
\title{wrapper function for fitting and summaries}
\usage{
lcm_tree(
  Y,
  leaf_ids,
  mytree,
  weighted_edge = TRUE,
  Z_obs = NULL,
  ci_level = 0.95,
  get_lcm_by_group = FALSE,
  update_hyper_freq = 50,
  print_freq = 10,
  quiet = FALSE,
  plot_fig = FALSE,
  shared_tau = FALSE,
  hyper_fixed = list(K = 3),
  tol = 1e-08,
  tol_hyper = 1e-04,
  max_iter = 5000,
  nrestarts = 3,
  keep_restarts = TRUE,
  parallel = TRUE,
  log_restarts = FALSE,
  log_dir = ".",
  vi_params_init = list(),
  hyperparams_init = list(),
  random_init = FALSE,
  random_init_vals = list(tau_lims = c(0.5, 1.5), psi_sd_frac = 0.2, phi_sd_frac = 0.2,
    mu_gamma_sd_frac = 0.2, mu_alpha_sd_frac = 0.2, u_sd_frac = 0.2),
  allow_continue = FALSE
)
}
\arguments{
\item{Y}{An \code{n} x \code{J} matrix of binary (0 or 1) measurements,
where each of n observation may belong to a leaf node; we hope to group n subjects into
groups possibly coarser than the leaf-induced groups, and in each group, we have a homogeneous latent
class model}

\item{leaf_ids}{Character vector of length \code{n}. \code{leaf_ids[i]} is a string indicating the
leaf_ids experienced by unit \code{i}.}

\item{mytree}{A directed \code{igraph} object. This is a tree representing the relationships
among the leaf_ids. The leaves represent individual leaf_ids, and internal nodes
represent leaf_ids categories consisting of their leaf descendants. All nodes
of mytree must have unique names as given by \code{names(V(mytree))}. The names of the leaves must
be equal to the unique elements of leaf_ids. The vertices of \code{mytree}, \code{V(mytree)}, may have
an attribute \code{levels} containing integer values from 1 to \code{max(V(mytree)$levels)}.
In this case, the levels attribute specifies groups of nodes that share common
hyperparameters \code{rho[f]}, \code{tau_1[f]}, and \code{tau_2[f]}. If \code{V(mytree)$levels} is \code{NULL},
the default is two levels of hyperparameters: one for all leaf nodes, and one
for all internal nodes. NB: this needs to be checked in the \code{\link[=design_tree]{design_tree()}}}

\item{weighted_edge}{default to \code{TRUE}, which indicates the model will
use the values of branch lengths (\code{h_pau} of \code{V(mytree)}).}

\item{Z_obs}{a matrix of two columns, first column is subject ids (of all samples),
the second column is a mix of NA or integers: NA for unknown and integers for known
classes.}

\item{ci_level}{A number between 0 and 1 giving the desired credible interval.
For example, \code{ci_level = 0.95} (the default) returns a 95\% credible interval}

\item{get_lcm_by_group}{If \code{TRUE}, lotR will also return the maximum likelihood estimates of the
coefficients for each leaf_ids group discovered by the model.
Default is \code{TRUE}.}

\item{update_hyper_freq}{How frequently to update hyperparameters.
Default = every 50 iterations.}

\item{print_freq}{How often to print out iteration number and current value of epsilon
(the difference in objective function value for the two most recent iterations).}

\item{quiet}{default to FALSE, which prints empirical class probabilities and updates on
tau's}

\item{plot_fig}{plot figure about prob and response profile (1st node)}

\item{shared_tau}{logical: \code{TRUE} for sharing the tau_1 for alpha's in
the same node; same for tau_2 (gamma's). Default is \code{FALSE}}

\item{hyper_fixed}{Fixed values of hyperprior parameters for rho.
This should be a list with two elements:
a and b, both numeric vectors of length \code{L}, representing the
parameters of the beta prior on rho for each level, where \code{L} is the
number of levels.
Default is \code{list(a = rep(1, L), b = rep(1, L), tau_update_levels = c(1,2))} (uniform hyperprior)
Other options include specifying included or excluded nodes via
e.g., \verb{s_u_zeroset = (1:265)[-c(1)],s_u_oneset = c(1))} to fit a single
big LCM (collapsing all nodes except the root node, the first node)}

\item{tol}{Convergence tolerance for the objective function.
Default is \code{1E-8}.}

\item{tol_hyper}{The convergence tolerance for the objective function between
between subsequent hyperparameter updates. Typically a more generous
tolerance than \code{tol}.
Default is \code{1E-4}.}

\item{max_iter}{Maximum number of iterations of the VI algorithm.
Default is 5000.}

\item{nrestarts}{Number of random re-starts of the VI algorithm. The result that
gives the highest value of the objective function will be returned.
It is recommended to choose \code{nrestarts > 1}.
The default is 3.}

\item{keep_restarts}{If \code{TRUE}, the results from all random restarts will be returned.
If \code{FALSE}, only the restart with the highest objective function is returned. '
Default is \code{TRUE}.}

\item{parallel}{If \code{TRUE}, the random restarts will be run in parallel.
It is recommended to first set the number of cores using \code{doParallel::registerDoParallel()}.
Otherwise, the default number of cores specified by the \code{doParallel} package will be used.
Default is \code{TRUE}.}

\item{log_restarts}{If \code{TRUE}, when \code{nrestarts > 1} progress of each random restart will be
logged to a text file in \code{log_dir}. If \code{FALSE} and \code{nrestarts > 1},
progress will not be shown.
If \code{nrestarts = 1}, progress will always be printed to the console.
Default is \code{FALSE}.}

\item{log_dir}{Directory for logging progress of random restarts.
Default is the working directory.}

\item{vi_params_init, hyperparams_init}{Named lists containing initial values for the
variational parameters and hyperparameters. Supplying good initial values can be challenging,
and \code{lotR()} provides a way to guess initial values based on transformations
of conditional logistic regression estimates of the effect sizes
for each individual leaf_ids (see \code{\link[=initialize_tree_lcm]{initialize_tree_lcm()}}).
The most common use for \code{vi_params_init} and \code{hyperparams_init} is to supply starting
values based on previous output from \code{lotR()};
see the \code{vignette('lotR')} for examples.
The user can provide initial values for all parameters or a subset.
When initial values for one or more parameters are not
supplied, the missing values will be filled in by \code{\link[=initialize_tree_lcm]{initialize_tree_lcm()}}.}

\item{random_init}{If \code{TRUE}, some random variability will be added to the initial values.
The default is \code{FALSE}, unless \code{nrestarts > 1}, in which case
\code{random_init} will be set to \code{TRUE} and a warning message will be printed.
The amount of variability is determined by \code{random_init_vals}.}

\item{random_init_vals}{If \code{random_init = TRUE},
this is a list containing the following parameters for randomly permuting
the initial values:
\describe{
\item{\code{tau_lims}}{a vector of length 2, where \code{tau_lims[1]} is between 0 and 1,
and \code{tau_lims[2] > 1}. The initial values for the hyperparameter \code{tau} will
be chosen uniformly at random in the range \verb{(tau_init * tau_lims[1], tau_init * tau_lims[2])},
where \code{tau_init} is the initial value for \code{tau} either supplied in \code{hyperparams_init}
or guessed using \code{\link[=initialize_tree_lcm]{initialize_tree_lcm()}}.}
\item{\code{psi_sd_frac}}{a value between 0 and 1. The initial values for the auxiliary parameters
\code{psi} will have a normal random variate added to them with standard deviation equal to
\code{psi_sd_frac} multiplied by the initial value for eta either supplied in \code{hyperparams_init} or guessed
using \code{\link[=initialize_tree_lcm]{initialize_tree_lcm()}}. Absolute values are then taken for any
values of \code{psi} that are \verb{< 0}.}
\item{\code{phi_sd_frac}}{same as above}.
\item{\code{mu_gamma_sd_frac}}{a value between 0 and 1. The initial values for
\code{mu} will have a normal random variate added to them with standard deviation equal to
\code{mu_sd_frac} multiplied by the absolute value of the initial value for \code{mu_gamma_sd_frac} either supplied in
\code{vi_params_init} or guessed using \code{\link[=initialize_tree_lcm]{initialize_tree_lcm()}}.}
\item{\code{mu_alpha_sd_frac}}{same as above.}
\item{\code{u_sd_frac}}{a value between 0 and 1. The initial value for the node inclusion probabilities
will first be transformed to the log odds scale to obtain \code{u}. A normal random variate will be
added to \code{u} with standard deviation equal to u_sd_frac multiplied by the absolute value of the
initial value for \code{u} either supplied in \code{vi_params_init} or guessed using \code{moretrees_init_logistic()}.
\code{u} will then be transformed back to the probability scale.}
}}

\item{allow_continue}{logical, TRUE to save results so can continue running the VI
updates with the last iteration from the old results.}
}
\value{
a list also of class "lcm_tree"

\describe{
res <- make_list(mod,mod_restarts,mytree,dsgn,prob_est,est_ad_hoc)
class(res) <- c("lcm_tree","list")
}
}
\description{
wrapper function for fitting and summaries
}
\examples{
### Example workflow of `lotR`
### Zhenke Wu | zhenkewu@gmail.com
### August 04, 2020
### This example has true parameters following the tree structured priors.
rm(list=ls())
library(lotR)

data("lotR_example_edges")
library(igraph)
tr <- graph_from_edgelist(lotR_example_edges, directed = TRUE) # Plot tree
# here in this example, we use equal weighted edges.

# If needed, first install ggtree
# if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
# BiocManager::install("ggtree")
library(ggtree)
library(ggplot2)
ggtree(tr, ladderize = FALSE, layout = "slanted") +
  geom_tiplab(geom = "label") + geom_nodelab(geom = "label") +
  theme(plot.margin = unit(c(0, 1.5, 0, 0.2), "cm")) +
  coord_cartesian(clip = "off") + scale_y_reverse()

leaves <- names(igraph::V(tr)[degree(tr, mode = "out") == 0])

# set levels: leaves 2, non-leaves 1
igraph::V(tr)$levels <- rep(1,length(igraph::V(tr)))
igraph::V(tr)$levels[match(names(igraph::V(tr)[igraph::degree(tr, mode = "out") == 0]),
                   names(igraph::V(tr)))] <- 2

###############################################################################
## illustration of lotR on simulated data:
###############################################################################
data("lotR_example_data_tree") # assumes a single pi for all observations.
Y     <- lotR_example_data_tree$Y
Z_obs <- lotR_example_data_tree$Z_obs
curr_leaves <- lotR_example_data_tree$curr_leaves
theta <- lotR_example_data_tree$truth$itemprob
pi_mat <- lotR_example_data_tree$truth$pi_mat
# in the simulation, the 1st class has the highest level of probabilities,
# so we will reorder obtained estimates to match the meaning of classes.
Z     <- lotR_example_data_tree$truth$Z

## check if all leave names are present in the data.
setequal(leaves, unique(curr_leaves))
#> [1] TRUE
knitr::kable(table(curr_leaves))

K     <- nrow(theta)
p     <- length(V(tr))
J     <- ncol(Y)

dsgn0  <- design_tree(Y,curr_leaves,tr,weighted_edge = FALSE,Z_obs)

nrestarts <- 1
# doParallel::registerDoParallel(cores = nrestarts)
# log_dir <- tempdir()
# dir.create(log_dir)
set.seed(345083)
par(mfrow=c(3,3));plot(0,0)
mod0     <- lcm_tree(Y,curr_leaves,tr,
                     weighted_edge = !TRUE,
                     Z_obs         = Z_obs,
                     parallel      = TRUE,
                     hyper_fixed   = list(K=K,a=c(1,1),b=c(1,1),
                                          tau_update_levels = c(1,2),
                                          # should this be set as default?
                                          s_u_zeroset = NULL,
                                          s_u_oneset = c(1)),
                     # hyperparams_init = list(tau_1=matrix(9/4,nrow=2,ncol=K-1),
                     #                         tau_2=array(9/4,c(2,J,K))),
                     vi_params_init = list(prob=rep(0.95,p)),
                     random_init = !TRUE,
                     nrestarts     = nrestarts,
                     quiet         = !TRUE,
                     plot_fig      = TRUE,
                     shared_tau    = FALSE,
                     get_lcm_by_group = TRUE, #<--- check what are the prereq.
                     print_freq    = 10,update_hyper_freq = 50, max_iter = 5000,
                     tol           = 1e-6,
                     tol_hyper     = 1e-3,
                     allow_continue = FALSE)#,
#log_restarts =!TRUE,
#log_dir = log_dir)

###############################################################################
# print out summaries of group specific estimates:
###############################################################################
plot(mod0,layout = "slanted", horizontal = FALSE)

print(mod0)

which(mod0$mod$vi_params$prob>0.5)
unique(lotR_example_data_tree$truth$pi_mat)

}
\concept{lcm_tree functions}
