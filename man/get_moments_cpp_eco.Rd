% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{get_moments_cpp_eco}
\alias{get_moments_cpp_eco}
\title{Calculate variational moments during the updates (only for node u)}
\usage{
get_moments_cpp_eco(
  leaves_u,
  E_beta,
  E_beta_sq,
  E_eta,
  E_eta_sq,
  prob,
  prob_gamma,
  mu_gamma,
  sigma_gamma,
  mu_alpha,
  Sigma_alpha,
  anc,
  cardanc
)
}
\arguments{
\item{leaves_u}{the leaf descendant node ids for node u}

\item{E_beta, E_beta_sq, E_eta, E_eta_sq}{moment updates produced by \code{\link[=get_moments_cpp]{get_moments_cpp()}}}

\item{prob}{variational probabilities for \code{s_u}; length p}

\item{prob_gamma}{should be fixed: \code{c(1,rep(0,p-1))}}

\item{mu_gamma}{variational Gaussian means (for \code{s_u=1} component) for J*K
logit(class-specific response probabilities); (J,K,p) array; In R, we used a list of p (J,K) matrices}

\item{sigma_gamma}{variational Gaussian variances (for \code{s_u=1} component)
for J*K logit(class-specific response probabilities); (J,K,p) array}

\item{mu_alpha}{variational Gaussian mean vectors (for \code{s_u=1} component) -
this is a p by K-1 matrix; in R, we used a list of p vectors (each of length K-1)}

\item{Sigma_alpha}{variational Gaussian variances (for \code{s_u=1} component)
\itemize{
\item this is an array of dimension (K-1, K-1, p); in R, we used a list of p matrices,
each of dimension K-1 by K-1.
}}

\item{anc}{a list of pL vectors, each vector has the node ids of the ancestors;
lengths may differ. The ancestors include the node concerned.}

\item{cardanc}{a numeric vector of length pL; integers. The number
of ancestors for each leaf node}
}
\value{
a List

\describe{
return List::create(Named("E_beta")=E_beta,
Named("E_beta_sq")=E_beta_sq,
Named("E_eta")=E_eta,
Named("E_eta_sq")=E_eta_sq);
}
}
\description{
update only selected moments that need update when iterating over u (except for \code{rmat})
}
\details{
(one-node version of \code{\link[=get_moments_cpp]{get_moments_cpp()}})
}
\examples{
# illustrates the calculation of the various moments:

prob = 0.2
mu1 = 2
mu0 = 0

sigma1 = 3
sigma0 = 1

N = 10000
s = rbinom(N,1,prob)
y <- rep(NA,length(s))
for (i in seq_along(s)){
      y[i] <- rnorm(1,mu1,sqrt(sigma1))*s[i] +
        rnorm(1,mu0,sqrt(sigma0))*(1-s[i])
}

var(s*y)
prob*(sigma1+(1-prob)*mu1^2)

mean(y^2)
prob*(sigma1+mu1^2) + (1-prob)*sigma0

mean(s*y^2)
prob*(sigma1+mu1^2)

mean(s*y)
prob*mu1
}
